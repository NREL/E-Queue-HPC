import sys
from typing import Any, Dict, Optional

import psycopg

from jobqueue.connect import connect, release_pooled_connection


class CursorManager:
    """
    Context Manager wrapping a psycopg cursor and connection.
    Makes sure to close the cursor and release the connection, or return it
    to a connection pool when the manager's scope exits.
    Passes along any exception, or exceptions generated by closing the
    cursor or connection.

    Will prioritize raising the original exception over exceptions generated
    by closing the cursor or connection.
    """

    def __init__(
        self,
        credentials: Dict[str, Any],  # database connection settings
        **kwargs
    ):
        self._credentials: Dict[str, Any] = credentials
        self._connection = None
        self._pooling: bool = False
        self._cursor: Optional[psycopg.Cursor] = None
        self._connection_kwargs: Dict[str, Any] = kwargs

    def __enter__(self) -> psycopg.Cursor:  # type: ignore
        try:
            self._pooling = self._credentials.get("pooling", False)
            connection = connect(self._credentials)
            self._connection = connection
            self._cursor = connection.cursor(**self._connection_kwargs)
            return self._cursor
        except Exception as e:
            if not self.__exit__(*sys.exc_info()):
                raise e

    def __exit__(self, exception_type, exception_value, traceback):
        connection = self._connection
        self._connection = None

        cursor_: Optional[psycopg.Cursor] = self._cursor
        self._cursor = None

        exception = exception_value

        def do_and_capture(func):
            nonlocal exception
            try:
                func()
            except Exception as e:
                if exception is None:
                    exception = e

        if cursor_ is not None and not cursor_.closed:
            do_and_capture(lambda: cursor_.close())

        if connection is not None:
            if self._pooling:
                do_and_capture(
                    lambda: release_pooled_connection(self._credentials, connection)
                )
            else:
                do_and_capture(lambda: connection.close())

        if exception is not None:
            raise exception

        return False
